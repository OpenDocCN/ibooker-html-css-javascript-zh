# 10

基于浏览器的可视化

**本章涵盖**

+   使用 C3 进行基于浏览器的可视化

+   理解各种图表：折线图、柱状图、饼图和散点图

+   建立图表模板，以便您可以快速开始新项目

+   快速原型化图表

+   创建一个简单的 Web 服务器和 REST API 来为您的可视化提供服务

+   为您的图表添加各种视觉和交互式改进

现在我们来到了 JavaScript 最擅长的数据处理方面！

在网页浏览器中运行 JavaScript 是**唯一**托管交互式可视化之处。通过可视化，我们将我们的数据公之于众。这是我们更好地理解数据的方式。以这种方式查看数据可以比我们通过查看原始数字所能希望达到的更有效地将信息传递给我们的大脑。

可视化是我们将有关我们数据的信息传达给我们的观众的方式，无论他们是谁；它允许知识和理解的转移。我们可以轻松地识别和指出有趣的趋势、模式或数据点。

在第九章中，我们分析了我们的数据，在分析过程中，我们查看了许多图表。在这一章中，让我们退后一步，学习如何为自己创建这样的图表。

我们将使用 C3 可视化库并创建一系列包含图表的简单工作 Web 应用。我们将从纽约市的年温度折线图开始。在我们尝试其他图表类型之前，我们将对第一个图表进行各种改进。

## 10.1 扩展您的工具箱

本章我们将使用的主要工具是 C3 可视化库。JavaScript 有许多可视化库，那么为什么我选择 C3 作为本章的工具呢？

好吧，我们必须从某个地方开始，而 C3 是一个方便且易于开始的起点。大多数简单的图表都是声明性的（它们通常可以用在 JSON 文件中指定的图表定义来声明），尽管我们也有在需要时使用代码的能力。C3 直接提供了交互性，我们甚至可以制作简单的动画图表。

C3 被广泛使用，社区支持强大，并且处于持续的开发和改进中。但没有任何库是完美的，C3 也有其局限性。当我们超越简单的图表时，我们会发现它的限制；然而，我相信 C3 的易用性和快速原型化简单图表的能力使其成为我们工具箱中的绝佳补充。

选择 C3 的另一个好理由是它基于 D3，正如您可能非常了解的，D3 是 JavaScript 中首屈一指的可视化工具包。但既然 D3 如此出色，为什么还要选择 C3 而不是它呢？

D3 是一个用于开发动态和交互式网络可视化的高级工具包；我们将在第十三章中了解更多关于它的内容。D3 很棒，但缺点是它也很复杂，学习曲线陡峭。C3 是 D3 的简化包装器，在创建常见类型的图表时使用起来要容易得多。C3 提供了一系列模板图表，我们可以对其进行配置，但背后有 D3 的强大功能。

我提到 D3 不仅因为其在 JavaScript 可视化社区中的重要性。你还需要知道，当你达到 C3 的极限时，你可以开始使用 D3 API 来定制你的图表。这导致了一个全新的复杂度级别，但它确实在我们达到 C3 的极限时为我们提供了一种前进的方式，通过这种方式，我们可以将 C3 视为迈向完整 D3 的垫脚石，前提是你所追求的是这个目标。

## 10.2 获取代码和数据

本章的代码和数据可在 GitHub 上的 Data Wrangling with JavaScript Chapter-10 仓库中找到。

`````` `[`github.com/data-wrangling-with-javascript/chapter-10.`](https://github.com/data-wrangling-with-javascript/chapter-10.)`   ````` `Each subdirectory in the repository corresponds to a code listing in this chapter and contains a complete and working browser-based visualization.`   ````These examples can be run using live-server as your web server. Install live-server globally as follows:    ``` npm install -g live-server  ```    You may now use live-server to run listings 10.1 to 10.3, for example (also installing dependencies):    ``` cd Chapter-10/listing-10.1 bower install live-server  ```    Live-server conveniently opens a browser to the correct URL, so you should immediately see your visualization onscreen.    The later code examples in this chapter include a Node.js–based web server, so you must use both npm and Bower to install dependencies, for example:    ``` cd Chapter-10/listing-10.4 npm install cd public bower install  ```    You must run the Node.js app to start the web server for listing 10.4 and on as follows:    ``` cd Chapter-10/listing-10.4 node index.js  ```    You can now open your browser to the URL [`localhost:3000`](http://localhost:3000) to view your visualization.    Refer to “Getting the code and data” in chapter 2 for help on getting the code and data.    ## 10.3 Choosing a chart type    When starting a visualization, we must first choose a chart type. In this chapter, we’ll cover the chart types shown in figure 10.1. Table 10.1 lists the chart types along with a brief explanation of the best use of each type of chart.    Table 10.1 Chart types and their uses     | **Chart Type** | **Uses** | **Example** | | --- | --- | --- | | Line chart | Time series data or continuous data set | NYC yearly temperature | | Bar chart | Comparing groups of data to each other | NYC monthly temperature | |  | Analyzing distributions of data (also known as a histogram) | Understanding the distribution of temperatures in NYC | | Pie chart | Comparing groups to the whole, but only a snapshot in time | Comparing the monthly temperatures in 2016 | | Scatter plot | Understanding the relationship and correlation between data variables | Understanding the relationship between rainfall and umbrella sales |  ![c10_01.tif](img/c10_01.png)    Figure 10.1 The types of charts we'll create in chapter 10      To get started, we have to pick one type of chart. We’ll start with a line chart because that’s one of the most common charts, and it also happens to be the default for C3 when you don’t choose any particular type of chart.    ## 10.4 Line chart for New York City temperature    We’re going to start with C3 by learning how to construct a line chart. We’ll first create a simple chart template with hard-coded data and use live-server so that we can prototype our chart without having to first build a web server.    We’ll then add in a CSV data file so that we’re rendering our chart from real data. Ultimately, we’ll work up to building a simple web server that delivers the data to our web app for rendering in the chart. Figure 10.2 shows what you can expect from the end product: a line chart of the yearly average temperature in New York City. You might remember this chart from chapter 9.  ![c10_02.tif](img/c10_02.png)    Figure 10.2 A line chart showing yearly average temperature for New York City      Even though we’re starting our visualization journey with a line chart, it’s easy to convert to almost any other chart type. Indeed, C3 has a facility that allows us to create an animated transition from one chart type to another. For example, we could do an animated transition from the line chart to a bar chart. But let’s not get ahead of ourselves; we need to start with the basics, and then later in the chapter we’ll learn more about the advanced features.    ### 10.4.1 The most basic C3 line chart    When I start work on a project, I like to start as simply as possible. As you’ve learned from other chapters, my philosophy on coding is to start small, get it to work, then evolve and refine it through incremental changes, all the while keeping it working. I like to take my code through an evolution toward my end goal. On the way, I take it through a series of transitions from working state to working state so that I keep the code working and problems aren’t allowed to accumulate.    We’re going to start our web-based visualization with a simple web app. We’ll use static web assets and hard-coded data so that we don’t have to build a custom web server. Instead, we’ll use live-server as our off-the-shelf web server (live-server was first introduced in chapter 5). We can install live-server globally on our system as follows:    ``` npm install -g live-server  ```    Now we can run live-server from the command line in the same directory as our web project, and we’ll have an instant web server. To see this in action, open a command prompt, change directory to the listing-10.1 subdirectory in the GitHub repo for this chapter, install dependencies, and then run live-server as follows:    ``` > cd Chapter-10/listing-10.1 > bower install > live-server  ```    Live-server automatically opens a web browser, so we should now see our first C3 chart rendered as shown in figure 10.3. You can follow this same pattern for each of the code listings up to listing 10.4 (where we abandon live-server and create our own web server). Change the directory to the appropriate subdirectory for the code listing and run the `live-server` command (making sure you install dependencies the first time you run each listing).    Our web app project is composed of an HTML file (index.html), a JavaScript file (app.js), and a collection of third-party components installed through Bower. You can see what the file system for this project looks like on the left-hand side of figure 10.4.    When we run live-server in the same directory as our project, it connects the web browser to our web project, and what we’re looking at is index.html rendered in the browser after the JavaScript has executed and rendered our chart (as represented on the right-hand side of figure 10.4).    Listings 10.1a and 10.1b show the HTML and JavaScript files for our first C3 chart. If you haven’t already, please run live-server for listing 10.1 so you can see the results of the code later. Don’t forget to first install the Bower dependencies.  ![c10_03.tif](img/c10_03.png)    Figure 10.3 The most basic possible C3 chart; we’ll use this as our template chart.      Listing 10.1a The HTML file for our C3 chart template (listing-10.1/index.html)    ``` <!doctype html> <html lang="en">     <head>         <title>C3 chart template</title>   <link href="bower_components/c3/c3.css" rel="stylesheet">    ①       </head>     <body>  <div id='chart'></div>    ②     <script src="bower_components/jquery/dist/jquery.js"></script>    ③    <script src="bower_components/d3/d3.js"></script>    ④    <script src="bower_components/c3/c3.js"></script>    ⑤    <script src="app.js"></script>    ⑥       </body> </html>  ```  ![c10_04.eps](img/c10_04.png)    Figure 10.4 Live-server is our web server while prototyping.      Listing 10.1a is a minimal HTML file for our C3 chart. It includes CSS and JavaScript files for C3\. It includes jQuery so that we can have a callback when the document is loaded and for its AJAX capabilities. It also includes the JavaScript file for D3 because C3 depends on that. Finally, it includes our own custom JavaScript file that is presented in the following listing.    Listing 10.1b The JavaScript file for our C3 chart template (listing-10.1/app.js)    ``` $(function () {    ①     var chart = c3.generate({    ②    bindto: "#chart",    ③    data: {    ④               json: {  "my-data": [30, 200, 100, 400, 150, 250],    ⑤               }         }     }); });  ```    Listing 10.1b is the JavaScript file that creates our first C3 chart. It initializes the chart after jQuery invokes our *document ready* callback. The chart is created by the call to `c3.generate`. We pass our *chart definition* as a parameter. Note that we supplied the chart with simple hard-coded data using the `json` field of the chart definition.    We use such simple data here as a starting point to check that our basic chart works, but for our next step let’s get real data in there.    To sum up, this is what we’ve done:    *   We created a simple web app containing the most basic C3 chart. *   We used hard-coded data to get started. *   We used live-server as our web server*and viewed our basic chart in the browser.*    *### 10.4.2 Adding real data    Now we’re going to introduce real data into our chart. We’ll read the data from a CSV data file that we’ll put in our web project. Figure 10.5 is a screenshot of our data file loaded in Excel; it includes the yearly average temperatures for New York City. You can find this data in the file data.csv in the listing-10.2 subdirectory of the Chapter-10 GitHub repo.  ![c10_05.png](img/c10_05.png)    Figure 10.5 NYC yearly temperature CSV file      After we plug our new CSV data file into our C3 chart and refresh the browser, we’ll see a line chart that looks like figure 10.6.  ![c10_06.tif](img/c10_06.png)    Figure 10.6 NYC average yearly temperature rendered from a static CSV file      We’re going to load our data from data.csv. We’ve placed this file in our web project next to our web assets, as you can see on the left-hand side of figure 10.7. I’ve given this file the generic data.csv filename to make it easier for you to use this code as a template for your own visualizations. In a bigger project that might have multiple data files, we’d probably want to give them more specific names—for example, NYC_yearly_temperatures.csv.  ![c10_07.eps](img/c10_07.png)    Figure 10.7 We add data file data.csv to our web project, and we can render a chart from it in the browser.      Even though we’re using real data now, we still don’t need a web server. This is because live-server gives us access to the file system of our web project. We use jQuery’s AJAX API to retrieve our CSV data file using an asynchronous HTTP transfer.    ### 10.4.3 Parsing the static CSV file    Getting the data is only part of the problem. The data we get back through live-server and jQuery is text data, and our simple visualization doesn’t yet have the capability to understand our CSV data. However, we’ve already learned the tools we need!    We’ll use Papa Parse again here, which we first used way back in chapter 3\. Papa Parse also works in the browser. If you followed the instructions in “Getting the code and data” and you’ve installed dependencies for the listing-10.2 subdirectory of the GitHub repo, you already have Papa Parse installed; otherwise, you can install it in a fresh web project as follows:    ``` bower install --save papaparse  ```    Listing 10.2a shows an updated HTML file. We’ve included Papa Parse’s JavaScript file so that we can use it to deserialize our CSV data. Note that we’ve also updated the title of the web page; that’s a small visual improvement to our web page.    Listing 10.2a HTML file for our chart of NYC average yearly temperature (listing-10.2/index.html)    ``` <!doctype html> <html lang="en">     <head>  <title>NYC average yearly temperature</title>    ①            <link href="bower_components/c3/c3.css" rel="stylesheet">     </head>     <body>         <div id='chart'></div>          <script src="bower_components/jquery/dist/jquery.js"></script>         <script src="bower_components/d3/d3.js"></script>         <script src="bower_components/c3/c3.js"></script>  <script src="bower_components/papaparse/papaparse.js"></script>    ②           <script src="app.js"></script>     </body> </html>  ```    The changes to the JavaScript file in listing 10.2b are more substantial. We’re now using jQuery’s `$.get` function to *get* our data from the web server (in this example that’s still live-server). This creates an HTTP GET request to live-server that is resolved asynchronously and eventually triggers our *then* callback when the data has been fetched (or otherwise calls the error handler if something went wrong).    Once the data is retrieved, we deserialize it from CSV data to a JavaScript array using Papa Parse. We now have the data in our core data representation*(read chapter 3 for a refresher on that), and we can plug the data into our chart using the `json` field in the chart definition. Because we have the data in the core data representation, any of our reusable JavaScript modules for transforming such data could potentially be reused here.*   *Listing 10.2b Retrieving CSV data to render to the C3 chart (listing-10.2/app.js)    ``` $(function () {   $.get("data.csv")    ①    .then(function (response) {    ②    var parseOptions = {    ③    header: true,    ④    dynamicTyping: true    ⑤               };  var parsed = Papa.parse(response, parseOptions);    ⑥     var chart = c3.generate({    ⑦                   bindto: "#chart",                 data: {  json: parsed.data,    ⑧                       keys: {                         value:   "AvgTemp"  [  ⑨                           ]                     }                 }             });         })  .catch(function (err) {    ⑩               console.error(err);         });  });  ```    Did you notice that the chart definition between listings 10.1b and 10.2b barely changed? In 10.2b we plugged in the real data that was retrieved from our CSV data file. The other change we made was to use the `keys` and `value` fields of the chart definition to specify the column from the CSV file to render in the line chart. A CSV file may contain many columns, but we don’t necessarily want them all to appear in our chart, so we restrict the chart to the column or columns we care about.    We’ve now added some real data to our chart. We added our CSV data file to our web project and relied on live-server to deliver the data to the browser where it was rendered to the chart.    I chose to use CSV here because it’s a common format for data like this. We might also have used a JSON file and that would have saved us effort because then we wouldn’t have needed Papa Parse to deserialize the data.    ### 10.4.4 Adding years as the X axis    If you take another look at figure 10.6, you will notice that the labels on the X axis indicate sequential numbers starting at 0\. This is supposed to be a chart of yearly average temperature, so how does the X axis in figure 10.6 relate to the year of each record?    The problem is that we didn’t explicitly tell C3 which column in the CSV file to use as the values for the X axis, so C3 defaulted to using a zero-based index for each data point. Look again at figure 10.5, and you can see a Year column that’s clearly an obvious candidate for the X axis; however, C3 has no way of knowing these are the correct values for the X axis!    We need to tell C3 to use the Year column for the X axis in our chart. When C3 knows this, it will now render the chart shown in figure 10.8. Notice now that the labels along the X axis show the correct years for the data points on the Y axis.  ![c10_08.png](img/c10_08.png)    Figure 10.8 NYC average yearly temperature now using the year as the X axis      We use the `keys` and `x` fields of the chart definition to set the data for our X axis. Note that listing 10.3 is similar to what’s shown in listing 10.2b, but we’ve set the `x` field to `Year`. Now C3 extracts the Year field from the data for use as the X axis.    Listing 10.3 Adding an X axis to the NYC temperature chart (extract from listing-10.3/app.js)    ``` var chart = c3.generate({     bindto: "#chart",     data: {         json: parsed.data,         keys: {  x: "Year",    ①               value: [                 "AvgTemp"             ]         }     } });  ```    Now we’ve prototyped a line chart within a simple web app. We’ve used live-server so that we didn’t have to create a web server. We started with hard-coded data, and then we upgraded it to read data from a CSV file. We haven’t yet seen any need to create a custom web server. As you can see, we can go a long way in our prototyping and development before we need to invest the time to build a custom Node.js web server.    You might even find that you don’t need to build a Node.js web server at all. I’m not saying you should use live-server to host a public website or visualization—you’d have production issues with that—but you could take any off-the-shelf web server (for example, Apache or nginx) and use it to host a public visualization such as we’ve produced so far in this chapter.    Maybe you’re creating a visualization that’s for yourself and not for public consumption? For example, you want to improve your own understanding of a data set or to take a screenshot to save for later. When you create a visualization that isn’t public-facing, you won’t require a production web server.    We’ll have many times, however, when we’ll want to build our own custom web server, and it’s not particularly difficult, so let’s now learn how to do that.    ### 10.4.5 Creating a custom Node.js web server    Although creating our own web server in Node.js isn’t strictly necessary for any of the visualizations in this chapter, it’s handy for a variety of reasons. In this section, we’ll expand on what we learned back in chapter 2 and build a simple web server and REST API that can host both our web app and the data it needs.    Each code listing that we’ve seen so far in this chapter (listings 10.1 to 10.3) has been a simple web project with static assets delivered to the browser through live-server. Now we’re going to move our web project into the context of a Node.js project that’s the web server that hosts the visualization.    We move our web project to the *public* subdirectory in the new Node.js project that’s shown on the left-hand side of figure 10.9. Also notice the *data* subdirectory. We’re still going to use a CSV data file, but we’ve moved it from the web project*to the *data* subdirectory. This is a convenient location where we can organize our data.*   *When we run the Node.js project, it will create a web server to host our web app and a REST API that delivers the data to it. Our web server now becomes the middleman between the server-side file system and the web app running in the browser (as shown in figure 10.9). What you should understand from this is that our data is no longer directly accessible to the public; we’re now forcing access to our data to go through our REST API. Because of this, we have the potential to control access to the data in whatever way we need. We’ll revisit this idea again soon.  ![c10_09.eps](img/c10_09.png)    Figure 10.9 After adding our Node.js web server and REST API, we take full control of how data is accessed from the browser.      Listing 10.4a shows the Node.js code for a simple web server, which does two things:    1.  Exposes the *public* subdirectory as static web assets. This allows the web app to be served to the web browser (similar to what live-server did). 2.  Creates a REST API that delivers our data to the web app.    You can run this script now like any other Node.js app. Open a command line, install npm and Bower dependencies, and then run the Node.js script:    ``` > cd Chapter-10/listing-10.4 > npm install > cd public > bower install > cd .. > node index.js  ```    Note that you might also want to use `nodemon` for live reload of the Node.js project; please refer to chapter 5 for details on that. Here we’re using the `express` library for our web server. You may have installed that in the example project already with `npm install`, or you can install it in a fresh Node.js project using the command:    ``` npm install --save express.  ```    Now open your web browser and enter [`localhost:3000`](http://localhost:3000) into the address bar. You should see a line chart of NYC yearly temperature. Please take note of the steps you followed; this is how you’ll run all subsequent code listings in the chapter. The following listing starts our web server.    Listing 10.4a Node.js web server to host our web app (listing-10.4/index.js)    ``` const express = require('express'); const path = require('path'); const importCsvFile = require('./toolkit/importCsvFile.js');  const app = express();  const staticFilesPath = path.join(__dirname, "public");    ①   const staticFilesMiddleWare = express.static(staticFilesPath); //  ①   app.use("/", staticFilesMiddleWare);    ①    app.get("/rest/data", (request, response) => {    ②     importCsvFile("./data/data.csv")    ③           .then(data => {  response.json(data);    ④           })         .catch(err => {             console.error(err);   response.sendStatus(500);    ⑤           }); });  app.listen(3000, () => {    ⑥       console.log("Web server listening on port 3000!"); });  ```    Note in listing 10.4a that we’re using the `importCsvFile` toolkit function that we created in chapter 3\. You’ll find that your most useful toolkit functions will be used time and again. This is the definition of a good reusable function!    We also now have a REST API. In listing 10.4a we attached an HTTP GET request handler to the URL `/rest/data`. We could have made this URL whatever we wanted, and we could have called it something more specific such as `/rest/nyc-temperature`, but in the interest of reusing this code listing as a template for your own visualizations, I’ve chosen to have a more generic name for the URL.    We can test that our REST API works with our browser. Enter [`localhost:300/rest/data`](http://localhost:300/rest/data) into your browser’s address bar, and you should see something similar to figure 10.10. This is what the data looks like when I view it in the browser (using Chrome with nice formatting provided by the JSON Viewer plugin).  ![c10_10.png](img/c10_10.png)    Figure 10.10 Browsing our temperature data REST API in the browser      To connect our web app to the REST API, we must change how it loads the data. Instead of loading the data from a static CSV data file (as we did in listing 10.2b), we now load it from the REST API as shown in listing 10.4b. Note that in both cases we’re still doing an HTTP GET request to the web server through jQuery’s `$.get` function, but now we’re using the URL of our new REST API rather than the URL of the CSV file.    In addition to the change in how the data is loaded, you’ll see another difference between listings 10.2b and 10.4b. We no longer need Papa Parse! We’re sending our data from server to web app in the JSON data format. jQuery `$.get` automatically deserializes the JSON data to a JavaScript data structure (the core data representation; see chapter 3). This simplifies the code for our web app, and it’s always nice when that happens.    Listing 10.4b The web app gets data from the REST API (extract from listing-10.4/public/app.js)    ``` $.get("/rest/data")    ①       .then(function (data) {  var chart = c3.generate({    ②               bindto: "#chart",             data: {                 json: data,                 keys: {                     x: "Year",                     value: [                         "AvgTemp"                     ]                 },  type: "line"    ③               }         });     })  ```    Why is it important to create our own web server and REST API? Well, I’ve already mentioned that it gives us the ability to control access to our data. To take this web app to production, we probably need a form of authentication. If our data is sensitive, we don’t want anyone to access it—we should make them log in before they can see data like that. We’ll talk more about authentication again in chapter 14.    Other important benefits exist for creating our own web server. One primary reason is so that we can create visualizations from data in a database. Figure 10.11 shows how we can put a database behind our web server (instead of CSV files in the file system). We can also use our REST API to dynamically process our data (retrieved from either database or files) before it’s sent to the web browser. Having a REST API is also useful in situations when we’re working with live data; that’s data that is fed into our pipeline in real time, an idea we’ll revisit in much detail in chapter 12.  ![c10_11.eps](img/c10_11.png)    Figure 10.11 Our data in a database with the web server as a secure gateway      As a parting note on REST APIs, please remember that it’s not always necessary to create a web server. In fact, I recommend that you go as far as you can prototyping your visualization *before* adding the extra complexity. Extra complexity slows you down. For the rest of this chapter, we don’t need the REST API, but I wanted to make sure that you’re ready to go with it because it’s commonplace to develop visualizations based on a database. And for that, you *do* need the REST API.    We’ve now created a web server and a REST API to serve our web app and feed it with data. You could say this is now a completed browser-based visualization. Although we still need to explore other types of charts, first let’s make improvements to our line chart.    ### 10.4.6 Adding another series to the chart    Let’s make upgrades and improvements to our chart. To start, we’ll add another data series to the chart to compare temperature between New York City and Los Angeles, similar to what we saw in chapter 9\. The resulting chart is shown in figure 10.12.  ![c10_12.tif](img/c10_12.png)    Figure 10.12 Combined chart with NYC and LA yearly temperatures      This example uses almost the exact same code as listing 10.4. We’re changing only two things:    1.  We replace data.csv in the Node.js project with a new data file that contains temperature columns for both NYC and LA. 2.  We modify the chart definition to add the new series to the chart. The updated code is shown in listing 10.5.    You can use this same process to create new visualizations for yourself. Take the code from listing 10.4 (or another listing that’s closer to your needs), replace the data with whatever new data you want, and then change the chart definition to suit your data. Continue to tweak the chart definition until you have a visualization that you’re happy with.    Listing 10.5 Rendering two data series into our chart to compare NYC temperature against LA (extract from listing-10.5/public/app.js)    ``` var chart = c3.generate({     bindto: "#chart",     data: {         json: data,         keys: {             x: "Year",             value:   "TempNYC",  [  ①    "TempLA"    ①               ]         }     } });  ```    Again, in listing 10.5 we use the `json` and `keys` fields in the chart definition to specify the data to render in the chart. Note that we’ve specified both the TempNYC and TempLA columns using the `value` field. This is what causes both data series to be rendered in the chart.    ### 10.4.7 Adding a second Y axis to the chart    Another thing we might want to do is add a second Y axis to our chart. Let’s say we want to compare temperature and snowfall in NYC. We take our chart from figure 10.8, and we add a snowfall data series to it. The result is shown in figure 10.13. Can you tell me what’s wrong with this chart?  ![c10_13.tif](img/c10_13.png)    Figure 10.13 Adding the snowfall series to the NYC yearly temperature chart. What’s wrong with this picture?      The problem is that temperature and snowfall have values that are on different scales, and this makes comparison impossible. Note that the line for temperature in figure 10.13 is basically a straight line even though we know that if we zoom in on it what we’ll see is not going to be a straight line (see figure 10.8 for a reminder). Now we could deal with this by *standardizing* both temperature and snowfall data sets the way we did in chapter 9\. This would have the effect of bringing both data sets into a comparable scale, but it would also change the values, and if the actual values are what we want to see in the chart, this isn’t going to work for us.    The simple fix for this is to add a second Y axis to our chart. You can see in figure 10.14 that we now have the temperature Y axis on the left-hand side of the chart and the snowfall Y axis on the right-hand side. This simple change allows us to compare data series side by side without having to make any modifications to our data.  ![c10_14.tif](img/c10_14.png)    Figure 10.14 Adding the snowfall series as the secondary Y axis makes it easier to compare the two series.      Listing 10.6 shows the simple changes we must make to our chart definition to move one of our data sets to the second Y axis. With the addition of the `axes` field, we specify which data series belongs to which Y axis. It’s important to note that the second Y axis is enabled under the `axis` field. The second Y axis is disabled by default, and you must enable it. Otherwise, it won’t appear in the chart!    Listing 10.6 Adding a second Y axis to the chart (extract from listing-10.6/public/app.js)    ``` var chart = c3.generate({     bindto: "#chart",     data: {         json: data,         keys: {             x: "Year",             value: [                 "AvgTemp",                 "Snowfall"             ]         },         axes: {  AvgTemp: "y",    ①    Snowfall: "y2"    ②           }     },     axis: {         y2: {  show: true    ③           }     } });  ```    ### 10.4.8 Rendering a time series chart    We haven’t rendered a proper time series chart, although we did use the year as our X axis. This might seem like a time series to us, but on a technical level, C3 will only consider it as a time series if we use actual dates as our X axis. Let’s have a quick look at how to do that.  ![c10_15.png](img/c10_15.png)    Figure 10.15 CSV file containing NYC daily temperatures (viewed in Excel)      In this example we’ll change our data to be a temperature time series for each day in 2016\. You can see an example of what this data looks like in figure 10.15. Note that the *Date column contains dates (in the Australian format, sorry U.S. readers).*   *Our new time series data is rendered by C3, as shown in figure 10.16.  ![c10_16.tif](img/c10_16.png)    Figure 10.16 Rendering average daily temperature for NYC as a time series chart      To render our time series data correctly, we must make small changes to our chart definition. The updated chart definition is shown in listing 10.7. First, we set the X axis to the *Date* column, but this isn’t anything groundbreaking yet.    The most important thing is that we set the X axis `type` to `timeseries`. C3 now interprets the *Date* series as date/time values. We haven’t used time in this example, but you could easily also add time to your date format.    Listing 10.7 Rendering a time series chart with formatted dates as labels for the X axis (extract from listing-10.7/public/app.js)    ``` var chart = c3.generate({     bindto: "#chart",     data: {         json: data,         keys: {  x: "Date",    ①               value: [ "AvgTemp" ]         }     },     axis: {         x: {  type: 'timeseries',    ②               tick: {  rotate : 50,    ③    format: '%Y-%m-%d',    ④    count: 12    ⑤               }         }     },     point: {  show: false    ⑥       } });  ```    The other changes to note in listing 10.7 are cosmetic. We’ve improved the look of the chart by setting the format and rotation of the tick labels.    ## 10.5 Other chart types with C3    We know how to create line charts with C3, but how do we create the other chart types?    It all comes down to the chart definition. We can change the chart definition and turn our line chart into any of the other chart types. This is trivial for bar charts, but for pie charts and scatter plots, we’ll have more work to prepare our data.    ### 10.5.1 Bar chart    Figure 10.17 is a bar chart that shows monthly temperature data for 2016 in NYC. The code that produces this bar chart is almost identical to the code for the line chart in listing 10.4. We’ve replaced the data, of course. The data shown in this chart was produced from raw data using the group and summarize technique that we covered in chapter 9.  ![c10_17.tif](img/c10_17.png)    Figure 10.17 NYC average monthly temperature for 2016 as a bar chart      We can start with the code from listing 10.4 and change the data; then we have one other thing we must do to turn it into a bar chart. As shown in listing 10.8, we change the `type` field in the `data` section to be `bar`. That’s it!    That’s all we need to do to convert a line chart to a bar chart. Listing 10.8 isn’t included in the Chapter-10 code repository, but you can try this yourself by taking listing 10.4 and setting the type to `bar`. Your result won’t look like figure 10.17 (you’ll need to update the data for that), but it will be a bar chart.    Listing 10.8 Changing the line chart to a bar chart    ``` var chart = c3.generate({     bindto: "#chart",     data: {         json: data,         keys: {             x: "Month",             value: [ "AvgTemp" ]         },  type: "bar"    ①       } });  ```    ### 10.5.2 Horizontal bar chart    It’s also trivial to convert our vertical bar chart to a horizontal bar chart, as shown in figure 10.18.    Listing 10.9 shows the small code change we make to listing 10.8 to make our bar chart horizontal. We set the `rotated` field from the `axis` section to `true`. We now have a horizontal bar chart!  ![c10_18.tif](img/c10_18.png)    Figure 10.18 NYC average monthly temperature for 2016 as a horizontal bar chart      Listing 10.9 Converting the vertical bar chart to a horizontal bar chart    ``` var chart = c3.generate({     bindto: "#chart",     data: {         json: data,         keys: {             x: "Month",             value: [ "AvgTemp" ]         },         type: "bar"     },     axis: {  rotated: true    ①       } });  ```    ### 10.5.3 Pie chart    Pie charts are great for showing how various parts compare to the whole. It may seem like an odd choice to plug temperature data into a pie chart, as shown in figure 10.19, but this does serve a purpose. Here we can easily pick out the hottest and coldest months in NYC by looking for the largest and smallest slices of the pie. In addition, we can use color coding to help identify the hottest and coldest months.    Preparation of the data for a pie chart is a bit different to the other charts in this chapter, so listing 10.10 is a larger code listing. In this code listing, we organize our data as a JavaScript object that maps the name of each month to the average temperature of that month. The chart definition for a pie chart is simple; it’s the data preparation that makes this a little more difficult.  ![c10_19.png](img/c10_19.png)    Figure 10.19 NYC average monthly temperature as a pie chart. The size of each slice and the color make it easy to pick out the hottest and coldest months in New York.    To see this figure in color, refer to the electronic versions of this book.      Listing 10.10 Restructuring the data and rendering a pie chart (listing-10.10/public/app.js)    ``` var monthNames = [     // ... Array that specifies the name of each month ... ];  var monthColor = [     // ... Array that specifies the color for each month in the chart ... ];  function getMonthName (monthNo) {    ①       return monthNames[monthNo-1]; }  function getMonthColor (monthNo) {    ②       return monthColor[monthNo-1]; }  $(function () {      $.get("/rest/data")         .then(function (data) {             var chartData = {};             var chartColors = {};  for (var i = 0; i < data.length; ++i) {    ③                   var row = data[i];                 var monthName = getMonthName(row.Month);  chartData[monthName] = row.AvgTemp;    ④                   chartColors[monthName] = getMonthColor(row.Month);             }              var chart = c3.generate({                 bindto: "#chart",                 data: {                     json: [ chartData ],                     keys: {                         value: monthNames                     },  type: "pie",    ⑤    order: null,                     colors: chartColors                 }             });         })         .catch(function (err) {             console.error(err);         });  });  ```    Pie charts are best used to show a snapshot of data composition at a particular point in time and can’t easily be used to represent time series data. If you’re looking for a type of chart that can be used to compare parts to the whole (like a pie chart) but over time, then consider using a stacked bar chart.    ### 10.5.4 Stacked bar chart    Figure 10.20 shows a bar chart with two data series. This sort of chart can be useful for comparing data side by side. It’s a bar chart with two data series, like the line chart shown in figure 10.12 but with the type set to `bar`.  ![c10_20.tif](img/c10_20.png)    Figure 10.20 A normal bar chart used for comparing average monthly temperature in NYC and LA      We can easily convert our two-series bar chart shown in figure 10.20 to a stacked bar chart. The result is shown in figure 10.21.  ![c10_21.tif](img/c10_21.png)    Figure 10.21 Converting the normal bar chart to a stacked bar chart might help us compare the proportions.      We stack our data series like this by organizing them into *groups*. In listing 10.11 we use the `groups` field to make groups from our data series and create the stacked bar chart from figure 10.21. There’s no code in the repository for listing 10.11, but you can easily create this yourself with a small modification to listing 10.5. Why don’t you try doing that?    Listing 10.11 Creating a stacked bar chart from two data series    ``` var chart = c3.generate({     bindto: "#chart",     data: {         json: data,         keys: {             x: "Month",             value: [ "TempNYC", "TempLA" ]         },  type: "bar",    ①           groups: [  [ "TempNYC", "TempLA" ]    ②           ]     } });  ```    ### 10.5.5 Scatter plot chart    The scatter plot is probably my favorite kind of chart, and it’s easy to create with C3\. As we learned in chapter 9, scatter plot charts are used to identify relationships between data variables. Figure 10.22 shows the scatter plot of rainfall versus umbrella sales that you might remember from chapter 9\. Let’s learn how to create this chart, and then we’ll improve the look of it.  ![c10_22.png](img/c10_22.png)    Figure 10.22 Scatter plot chart of NYC rainfall vs. umbrella sales      Listing 10.12 shows the simple chart definition required to create a scatter plot. We’re using the *Precipitation* (rainfall) column as our X axis and the *UmbrellaSales* column as our Y axis. The difference to the other charts is that we set the `type` field to `scatter`. That’s it, job done, we’ve created a scatter plot. Not difficult at all.    Listing 10.12 Creating a scatter plot chart comparing rainfall to umbrella sales in NYC (extract from listing-10.12/public/app.js)    ``` var chart = c3.generate({     bindto: "#chart",     data: {         json: data,         keys: {  x: "Precipitation",    ①    value: [ "UmbrellaSales" ]    ②           },  type: "scatter"    ③       } });  ```    ## 10.6 Improving the look of our charts    We have many ways we can improve our charts, starting with simple built-in options all the way up to advanced customizations using D3\. In this section, we’ll learn the simple options.    Look again at the scatter plot from figure 10.22. The X axis ticks are all bunched up. Let’s fix that and make other improvements.    We can easily control the number of ticks that are rendered on an axis and the formatting of the labels for the ticks. In figure 10.23 we’ve cleaned up the scatter plot, added nicely positioned labels for the X and Y axes, and hidden the legend (which wasn’t adding anything useful to this particular chart).  ![c10_23.tif](img/c10_23.png)    Figure 10.23 The scatter plot finished with nicely formatted axis labels and the legend hidden      Listing 10.13 shows the changes and additions made to listing 10.12 to get the desired formatting for our chart. Note that the labels for the axes and ticks have been set, formatted, and positioned. The legend is disabled to reduce clutter in the chart.    Listing 10.13 Various visual improvements have been applied to the scatter plot (extract from listing-10.13/public/app.js)    ``` var chart = c3.generate({     bindto: "#chart",     data: {         json: data,         keys: {             x: "Precipitation",             value: [ "UmbrellaSales" ]         },         type: "scatter"     },     axis: {         x: {             label: {  text: 'Rainfall',    ①    position: 'outer-center',    ②               },             tick: {  count: 8,    ③                   format: function (value) {  return value.toFixed(2);    ④                   }             }         },         y: {             label: {  text: 'Umbrella Sales',    ⑤    position: 'outer-middle'    ⑥               }         }     },     legend: {  show: false    ⑦       } });  ```    We could do more to this chart, including interactive features such as adding animation and dynamically adding new data points. C3 charts, by default, are interactive, so we already get nice tooltips and a legend that allows us to focus and highlight each data series.    ## 10.7 Moving forward with your own projects    As I’ve indicated already, you can use any of the code listings in this chapter as templates or starting points for your own C3 visualization projects.    To make a line or bar chart, you can start with listing 10.2 (if you don’t need a web server) or listing 10.4 (if you do need a web server). If you’re making a pie chart, you can start with listing 10.11. If you’re making a scatter plot, you can start with listing 10.13. Next, add your own data file; you can find other example CSV and JSON files in the GitHub repos for other chapters of this book. Then set the chart type to line, bar, pie, or scatter, depending on what you’re trying to achieve. Finish by tweaking the chart to make it look nice.    The process in summary:    1.  Copy listing 10.2 or listing 10.4 (or create your own template web app from scratch) from the Chapter-10 GitHub repo. 2.  Replace the data file in the project with new data of your choosing. 3.  Set the chart type. 4.  Tweak the chart definition to make it look nice.    We covered the standard charts that are available through the C3 library. C3 has much more to offer: other chart types, the ability to combine chart types, more configuration options, customization using D3, and support for interactivity. I encourage you to browse their example gallery and documentation to learn more.    In this chapter, we covered web-based interactive charts, but that’s not exactly what we were using for data analysis in chapter 9\. If you recall, we rendered charts in Node.js (on the server side), and we didn’t even once open a browser. We can easily render charts in Node.js, and this is incredibly useful when doing exploratory coding in Node.js when we don’t need or want an interactive visualization. We’ll continue our visualization journey in chapter 11 and learn how to render charts on the server-side in Node.js.    ## Summary    *   You learned about most common types of charts—line, bar, pie, and scatter plots—and how to create them using C3. *   We used live-server to quickly start prototyping visualizations without having to create a web server. *   We also created a custom web server and REST API to control how data is delivered to your browser-based visualization. *   We finished by learning how to format axis and tick labels for better-looking charts.****```` ````` ``````
