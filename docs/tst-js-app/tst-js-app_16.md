# 13 质量文化

本章涵盖了

+   如何类型补充你的测试并使你的代码更安全

+   代码审查的影响以及如何有效地执行它们

+   采用 linting 和格式化及其优势

+   设置监控以确保你的系统健康

+   文档如何影响你的项目质量

在 12 章关于 JavaScript 测试之后，第十三章稍微改变了方向。在本章中，我将教你一些新的技术，这些技术将补充你的测试并帮助你培养项目中的质量文化。

这些技术放大了测试的影响。它们使你的测试更安全，代码更容易理解，或者捕捉到测试无法捕捉到的错误。

本章首先演示了类型系统如何补充你的测试。在本节中，我讨论了采用类型系统的优势，并使用一个实际例子来说明你必须做什么才能从它们中获得最大的安全效益。

一旦我涵盖了类型系统，我将强调团队成员相互审查代码的重要性以及如何将这种实践融入你的开发流程。此外，本节还包含大量关于如何有效审查代码的建议。

为了简化代码审查并帮助开发者专注于代码语义而不是吹毛求疵，本章的第三部分描述了 linting 和格式化。它阐明了这两种实践之间的区别，并揭示了每种实践的好处。

本章的倒数第二部分解释了监控如何帮助保持你的软件健康，指出你的软件需要哪些更新，以及如何检测测试中无法捕捉到的错误。

最后，本章的最后部分讨论了每个人都消费但很少有人生产的东西：文档。本节涵盖了文档对你的团队软件和流程可能产生的影响，哪些类型的文档应该优先考虑，以及哪些**不应该**编写。

因为这本书专注于测试，所以我不会在每个部分中过多地详细说明。我本章的主要目标是让你了解这些实践和技术如何帮助你创建更好的软件。

在阅读本章后，我希望你能对你要寻找的内容有一个很好的了解，以及它如何融入软件测试的更大图景。

## 13.1 使用类型系统使无效状态不可表示

我认为测试是确认你关于程序如何工作的假设的实验。当你编写一个测试时，你对代码将要做什么有一个假设，所以你给它一些输入，并检查被测试的代码是否产生预期的输出。

一旦你运行了这些实验，你就会外推并选择相信程序在未来将以相同的方式工作，即使这可能并不正确。可能的情况是，你没有考虑到一些边缘情况，或者还有其他因素会影响代码的行为，例如如果你处理的是时间，时区可能会影响。

如我们之前所见，测试**不能**证明程序是有效的。它们只能证明程序不是无效的。

相反，使用类型系统**可以**证明程序的性质。如果你使用类型来指定一个函数只能接收数字，那么类型检查器会警告你，如果在该函数的任何情况下都可以用字符串调用该函数，例如。

与测试不同，类型系统**不是**基于实验的。它们基于清晰、逻辑的规则，你的程序需要遵守这些规则才能被认为是有效的。

假设，例如，你有一个函数将订单推送到面包店的配送队列。因为订单要被交付，它们需要是完整的，所以这个函数应该只向配送队列添加状态为 `done` 的订单。

列表 13.1 orderQueue.js

```
const state = {
  deliveries: []
};

const addToDeliveryQueue = order => {              ❶
  if (order.status !== "done") {
    throw new Error("Can't add unfinished orders to the delivery queue.");
  }
  state.deliveries.push(order);
};

module.exports = { state, addToDeliveryQueue };
```

❶ 只在订单状态为“完成”时添加订单到配送队列

如果你测试这个函数，你可能会编写一个测试来确保状态为 `in progress` 的订单不能添加到队列中，如以下代码片段所示。

列表 13.2 orderQueue.spec.js

```
const { state, addToDeliveryQueue } = require("./orderQueue");

test("adding unfinished orders to the queue", () => {            ❶
  state.deliveries = [];
  const newOrder = {
    items: ["cheesecake"],
    status: "in progress"
  };
  expect(() => addToDeliveryQueue(newOrder)).toThrow();
  expect(state.deliveries).toEqual([]);
});
```

❶ 一个测试以确保当有人尝试向配送队列添加状态为“进行中”的订单时，addToDeliveryQueue 会抛出错误

依赖于测试来断言程序质量的问题在于，由于 JavaScript 的动态特性，许多可能的输入可能导致程序的状态变得无效。例如，在这种情况下，有人可能向配送队列添加状态为 `done` 且项目为零或 `null` 的订单。

此外，可能还有其他函数会更新 `orderQueue.js` 中的状态，这可能导致无效状态。或者，更糟糕的是，有人可能尝试提交一个 `null` 订单，这会导致程序在检查订单状态是否为 `null` 时抛出错误。

为了覆盖这些边缘情况，你需要大量的测试，即使如此，你肯定也没有涵盖所有可能导致无效状态的可能场景。

为了约束你的程序，使其状态**必须**有效，你可以使用类型系统。

个人来说，TypeScript 的类型系统是我最喜欢的。它灵活且易于学习，其工具和社区都很优秀，这就是我选择用它来编写本节示例的原因。

在您开始使用类型来约束程序状态之前，请使用 `npm` 命令 `install` `-save` `typescript` 安装 TypeScript 作为开发依赖项。安装 TypeScript 后，运行 `./node_modules/.bin/tsc --init` 以创建一个初始的 TypeScript 配置文件，名为 `tsconfig.json`。最后，您还需要将文件的扩展名更改为 `.ts`。创建该文件后，您就可以开始使用类型来约束您的程序了。

例如，尝试创建一个表示订单的类型，并将类型分配给程序的状态。然后，更新 `addToDeliveryQueue` 函数，使其只能接受与 `Order` 类型匹配的订单。

列表 13.3 orderQueue.ts

```
export type Order = {                                               ❶
  status: "in progress" | "done";
  items: Array<string>;
};

export type DeliverySystemState = { deliveries: Array<Order> };     ❷

export const state: DeliverySystemState = { deliveries: [] };       ❸

export const addToDeliveryQueue = (order: Order) => {
  if (order.status !== "done") {
    throw new Error("Can't add unfinished orders to the delivery queue.");
  }
  state.deliveries.push(order);
};
```

❶ 定义一个类型，Order 的状态可以是“进行中”或“完成”，其项目由字符串数组表示

❷ 一个表示配送系统状态的类型，该状态包含一个名为 deliveries 的属性，它是一个订单数组

❸ 配送系统的状态，最初包含一个空的配送数组

注意：当使用 TypeScript 时，您可以使用 ES 导入语法，因为您将使用 TypeScript 编译器将程序转换为纯 JavaScript 文件。

仅通过这两个类型，您现在已经确保 TypeScript 如果代码中任何地方添加了除有效 `Order` 之外的内容，将会警告您。

例如，尝试调用 `addToDeliveryQueue` 并将其作为字符串参数传递。然后，使用 `./node_modules/.bin/tsc ./orderQueue.ts` 运行 TypeScript 编译器，您将看到程序无法编译。

列表 13.4 orderQueue.ts

```
// ...

// ERROR: Argument of type 'string' is not assignable to parameter of type 'Order'.
addToDeliveryQueue(null);
```

您甚至可以更进一步，并指定任何订单必须至少包含一个项目。

列表 13.5 orderQueue.ts

```
export type OrderItems = { 0: string } & Array<string>    ❶

export type Order = {
  status: "in progress" | "done";
  items: OrderItems;                                      ❷
};

export const state: { deliveries: Array<Order> } = {
  deliveries: []
};

export const addToDeliveryQueue = (order: Order) => {
  if (order.status !== "done") {
    throw new Error("Can't add unfinished orders to the delivery queue.");
  }
  state.deliveries.push(order);
};
```

❶ 定义值类型为 OrderItems 的值必须将其第一个索引填充为字符串

❷ 声明 items 属性具有 OrderItems 类型，这阻止程序员将其分配为空数组

此更新确保程序无法向配送队列添加 `items` 数组为空的订单。

列表 13.6 orderQueue.ts

```
// ...

//
      ERROR: Property '0' is missing in type '[]' but required in type '{ 0: string; }'.
addToDeliveryQueue({ status: "done", items: [] })
```

最后，为了减少您需要编写的测试数量，您还可以更新程序的类型，以确保 `addToDeliveryQueue` 只能接受状态为 `done` 的订单。

列表 13.7 orderQueue.ts

```
export type OrderItems = { 0: string } & Array<string>;

export type Order = {
  status: "in progress" | "done";
  items: OrderItems;
};

export type DoneOrder = Order & { status: "done" };                ❶

export const state: { deliveries: Array<Order> } = {
  deliveries: []
};

export const addToDeliveryQueue = (order: DoneOrder) => {
  if (order.status !== "done") {
    throw new Error("Can't add unfinished orders to the delivery queue.");
  }
  state.deliveries.push(order);
};
```

❶ 创建一个新类型，仅表示状态为“完成”的订单

现在，如果您的代码中任何地方有可能添加一个不完整的订单到配送队列，程序将无法编译。

列表 13.8 orderQueue.ts

```
// ...

// ERROR: Type '"in progress"' is not assignable to type '"done"'.
addToDeliveryQueue({
  status: "done",
  items: ["cheesecake"]
});
```

由于您使用了类型，您不再需要在函数内部进行错误处理或对其进行测试。因为您已经编写了严格的类型，如果您尝试向配送队列添加无效的订单，程序甚至无法编译。

列表 13.9 orderQueue.ts

```
export type OrderItems = { 0: string } & Array<string>;

export type Order = {
  status: "in progress" | "done";
  items: OrderItems;
};

export type DoneOrder = Order & { status: "done" };

export const state: { deliveries: Array<Order> } = {
  deliveries: []
};

export const addToDeliveryQueue = (order: DoneOrder) => {             ❶
  state.deliveries.push(order);
};
```

❶ 一个函数的参数类型为 DoneOrder，这阻止了其他人使用状态不是“完成”的任何订单调用它

在这些更改之后，您唯一需要的测试是检查`addToDeliveryQueue`是否将完整的项目添加到交付队列中的测试。

列表 13.10 orderQueue.spec.ts

```
import { state, addToDeliveryQueue, DoneOrder } from "./orderQueue";

test("adding finished items to the queue", () => {                     ❶
  state.deliveries = [];
  const newOrder: DoneOrder = {

    items: ["cheesecake"],
    status: "done"
  };
  addToDeliveryQueue(newOrder);
  expect(state.deliveries).toEqual([newOrder]);
});
```

❶ 一个测试将状态为“完成”的订单添加到交付队列中，并期望订单队列包含新订单

注意：在您能够编译此测试之前，您需要使用`npm install @types/jest`安装 Jest 的类型定义。

现在尝试使用`./node_modules/.bin/tsc ./*.ts`来编译所有`.ts`文件到纯 JavaScript，然后使用 Jest 运行测试以确认测试通过。

通过使用类型，您已经足够约束了您的程序，使得无效状态变得无法表示。这些类型帮助您覆盖了更多的边缘情况，而无需编写测试，因为 TypeScript 会在您编写不符合其期望的类型代码时警告您。此外，TypeScript 无需运行您的程序就能做到这一点。相反，TypeScript 会*静态地*分析程序。

此外，类型系统还有助于您在编写测试时犯更少的错误，因为它还会在您的测试可能导致程序进入无效状态时给出警告（假设您的类型足够严格，允许这种情况发生）。

注意：由于这本书专注于测试，我没有深入探讨 TypeScript 本身。如果您想了解更多关于 TypeScript 的信息，我强烈推荐 Marius Schulz 的 TypeScript Evolution 系列，您可以在[`mariusschulz.com/blog/series/typescript-evolution`](https://mariusschulz.com/blog/series/typescript-evolution)找到。

## 13.2 审查代码以捕捉机器无法发现的问题

机器只会做它们被告知的事情。它们不会犯错误；是人类会犯错误。每当软件行为异常时，都是人类的错。

代码审查存在是为了让人类指出彼此的错误，并改进软件的设计。此外，代码审查有助于在团队中分配所有权并传播知识。如果有人需要更改其他人编写的代码，他们已经阅读过它，并且更新它时会感到更舒适。

此外，代码审查可以帮助捕捉测试和类型检查无法发现的错误。在审查过程中，其他人可以指出，例如，存在没有自动化测试的边缘情况，或者存在不够严格的类型，无法防止程序进入无效状态。

如果您的团队还没有正式的代码审查流程，在绝大多数情况下，我建议您实施一个。即使您不使用拉取请求或其他任何正式方法，仅仅让其他人审阅您的代码也会带来显著的好处。

在本节中，我将向您介绍一些技巧，以确保您和您的团队能够从代码审查中获得最大收益。

这些技术中最重要的是**编写详细的拉取请求描述**，这允许其他人进行彻底的审阅。当其他人理解你的更改意图和所有细微差别时，他们可以避免添加重复的评论，指出你在编写代码时已经考虑过的事情。

个人而言，我喜欢在我的拉取请求中包含以下信息：

+   一个简要的总结，包含更改的意图和任何相关的跟踪器票据

+   对我正在解决的问题的深入解释，或者我正在实施的功能的细微差别

+   对我已编写或更新的代码片段的描述，强调我在实施过程中遇到的细微差别和问题

+   一个简要指南，说明我如何验证我的更改，以便其他人可以确认代码是正确的

提示：如果你使用 GitHub，你可以为这些项目中的每一个创建单独的拉取请求模板，这样其他人可以快速轻松地理解他们应该如何编写拉取请求描述。

一旦拉取请求描述达到这样的详细程度，那么审阅者的任务就是与作者沟通，确保代码的质量尽可能高。

我给审阅者的第一条建议总是将拉取请求视为一次对话。在进行审阅时，除了要求更改之外，我还建议其他人称赞作者的优雅设计并提问。

以与作者互动的意图审阅拉取请求迫使审阅者更加注意。此外，这种态度促进了更有意义和积极的互动。

在这些互动中，我还建议审阅者清楚地表明一个更改请求是否会阻止拉取请求获得他们的批准。这种指示有助于团队减少在琐碎或主观问题上浪费时间，这些问题可能连审阅者自己都没有认为那么重要。

此外，审阅者还应解释他们认为为什么特定的代码片段需要更改。通过描述采用建议方法的优势，他们使辩论更加流畅，并为作者提供更多考虑的信息，以便做出决定。

对于审阅者来说，最后的也许是最重要的建议是**在打开文本编辑器或 IDE 的情况下进行审阅**。在编写代码时，作者并不仅仅按字母顺序遍历文件并实施更改。相反，他们会找到更改的起点，并通过依赖图导航，更改他们需要的代码片段。因此，审阅**不应**是线性的。审阅者应根据依赖图和正在实施的更改来查看文件，而不是按字母顺序。

在你的编辑器或 IDE 打开的情况下审阅代码，可以让你检查可能没有更改但会影响拉取请求更改是否有效的其他代码片段。

总结一下，以下是一份关于如何审查拉取请求的这章所有建议的列表：

1.  编写详细的拉取请求描述。

1.  将每个拉取请求视为一次对话——无论你是否建议更改，都要带着添加评论的意图进行审查。

1.  明确指出你是否认为建议的更改是作者获得你批准所必需的。

1.  解释*为什么*你认为特定的代码片段需要更改。

1.  在打开文本编辑器或 IDE 的情况下审查拉取请求。跟随代码；不要线性地审查它。

在我参与的团队和开源项目中，我经常收到的最主要的赞扬之一就是我的拉取请求描述和审查非常详细和全面。这种纪律多次带来了显著的生产力提升和更多积极的互动。

最后，为了使你的更改更容易阅读和理解，尽量保持你的拉取请求小。如果你正在开发一个大型功能，你可以将其拆分为多个拉取请求，或者请求其他人审查你更改的中间状态。通常，当拉取请求太大时，人们会在 VCS 差异的众多代码行中错过重要的细节。

## 13.3 使用代码检查器和格式化工具生成一致的代码

本书的一个一致主题是，如果一台机器*能够*完成特定的任务，你应该将这项任务委托给它。代码检查和格式化就是这样的任务。

代码检查，类似于类型检查，是一种静态分析过程。当使用代码检查器时，它会分析你编写的代码，并验证它是否与可配置的规则集匹配。代码检查器可以指出可能导致错误或代码编写不一致性的问题。

你可以使用代码检查器在例如使用对象中重复的属性名称、声明未使用的变量、编写不可达的`return`语句或创建空代码块时触发警告。尽管所有这些结构在语法上都是有效的，但它们可能是多余的或导致缺陷。

通过使用代码检查器，你利用了机器无休止检查代码的能力，并让团队的其他成员有更多时间关注你编写的代码的实际语义。因为其他人可以相信机器已经完成了捕捉琐碎问题的任务，其他人可以专注于审查你代码的语义，而不是指出你有多余的`if/else`语句，例如。

```
/testing-javascript-applications/example.js                              ❶
  6:14  error   This branch can never execute.                           ❷
                Its condition is a duplicate or covered by previous
                conditions in the if-else-if chain
                no-dupe-else-if                                          ❸
```

❶ 发现代码检查错误的文件

❷ 错误的行号和列号，随后是对问题的解释

❸ 违反的代码检查规则名称

此外，许多工具和框架提供代码风格检查器插件，以便您的检查器可以警告您关于不良实践。假设您正在编写一个 React 应用程序，在这种情况下，您可以使用插件配置您的检查器，以便在您忘记指定组件属性的 `PropTypes` 时发出警告。

在撰写本文时，最受欢迎的 JavaScript 代码风格检查工具被称为 *ESLint*。它是一个可扩展且易于使用的检查器，您可以通过使用 `npm` 命令 `install` `--save-dev eslint` 将其作为开发依赖项安装。一旦安装，您可以通过运行 `./node_modules/.bin/eslint` `--init` 创建一个配置文件，并通过运行 `./node_modules/.bin/eslint .` 验证您的代码。

TIP 如您在本书中之前所见，如果您在 `package.json` 中创建一个运行 `eslint` 的 NPM 脚本，则可以省略 `node_modules` 文件夹中二进制的路径。在大多数项目中，您可能希望这样做。

除了指出危险的结构或不良实践外，代码风格检查器还可以指出并修复风格问题，例如双引号和单引号使用的不一致、不必要的括号或多余的空行。

个人而言，我不喜欢使用代码风格检查器来捕捉风格问题。相反，我更喜欢使用像 Prettier 这样的有偏见的代码格式化工具。

使用代码风格检查器处理代码风格的问题在于，您可以配置您的风格规则，尽管这个说法可能看起来有些反直觉，但在格式化方面，通常有更多的选择是件坏事。代码格式化非常主观，每个人在是否应该使用双引号或单引号、制表符或空格等方面都有自己的偏好——当然，空格的使用通常更好。

说实话，只要保持一致，代码风格并不重要。我不介意其他人更喜欢使用制表符而不是空格，只要整个代码库使用制表符即可。

通过使用 Prettier，您可以省去所有无意义的争论时间，并转而依赖 Prettier 的选择——正如我在编写本书的示例时所做的那样。

此外，Prettier 可以使代码更容易阅读，并且更愉快地工作。

NOTE 我喜欢说，讨论代码风格偏好总是 *无谓的争论*。无谓的争论发生在人们花费大量时间讨论项目中的琐碎且容易理解的部分，而不是专注于完成项目所需的最复杂和关键任务。

这个术语最初由 Poul-Henning Kamp 提出。它指的是 Cyril Northcote Parkinson 的虚构例子，用于他的琐碎法则，该法则指出，群体通常会对琐碎问题给予不成比例的重视。在他的例子中，Cyril 提到，一个负责批准核电站计划的委员会往往会花费大量时间讨论用于自行车棚的材料，而不是分析实际的核电站计划。

使用 Prettier 非常简单。要开始使用 Prettier 格式化你的代码，你只需要将其作为开发依赖项使用`npm` `install` `--save-dev prettier`安装，然后使用`./node_modules/.bin/prettier --write .`。

TIP 在我的项目中，我经常将 Prettier 与 Git 钩子集成，以便它将自动格式化我提交的所有代码。为此，我使用了在第十二章中介绍的工具`husky`。

## 13.4 监控你的系统以了解它们的实际行为

我从未听说过没有任何 bug 的软件。到目前为止，关于正确性的讨论和写作已经很多，但软件行业的现状清楚地表明，我们还没有找到编写无 bug 软件的方法。

正如在第三章中解释的那样，即使代码覆盖率达到了 100%，也不能保证你的软件没有 bug。有时，用户会使用你未曾预料到的特定输入来证明你的软件，bug *仍然会发生*。

监控基于假设问题*最终会发生*，并且最好在客户之前注意到它们。通过监控你的软件，你可以了解你对代码工作方式的哪些假设是不真实的。

此外，实施良好的监控系统将能够为你提供关于软件性能、资源消耗和利用的见解。

如果不收集关于你的软件*目前*做了什么的资料，就无法优化其性能，因为你将没有基准来比较你的更改，也不知道瓶颈在哪里。

或者，正如 Rob Pike 在他的五条编程规则中的第一条所陈述的（[`users.ece.utexas.edu/~adnan/pike.html`](https://users.ece.utexas.edu/~adnan/pike.html)）：

你无法预测程序将在哪里花费时间。瓶颈出现在令人惊讶的地方，所以不要试图猜测并添加速度优化，除非你已经证明了那里是瓶颈所在。

—Rob Pike

例如，如果你的客户抱怨你的网站加载时间过长，如果你不知道这些页面*目前*是如何表现的，你将如何显著提高页面加载时间？你当然可以尝试猜测瓶颈在哪里，但如果没有测量，你就是在黑暗中射击。

另一方面，如果你有足够的监控，你可以尝试几个不同版本的网站，每个版本都有不同的更改，并监控它们的性能，这样你才能真正了解每个更改的影响。

此外，测量可以让你避免过早优化你的软件。即使你可能已经编写了一个次优算法，也许它已经足够好，可以应对你的应用程序的负载。

测量。在你测量之前不要为了速度而调整，即使如此，除非代码的一部分明显超过了其他部分。

—Rob Pike

最后，设置监控基础设施的一个重要方面是，当你的监控系统检测到异常时，能够发送警报。如果你的 API 不可达或影响业务价值的东西不工作，应该有人被叫醒。

为了实现这一点，请确保你正在跟踪所有影响客户从你的软件中获得的价值的代码部分。除了启用警报外，衡量与你的软件提供给客户的价值更加紧密相关的方面，这将使你能够在未来做出有效的商业决策。

因为这是一本关于测试的书，所以我不打算详细介绍如何设置监控系统或合适的监控基础设施看起来像什么。做这件事需要整整一本书——实际上，可能需要很多本书。

然而，我认为强调监控在编写高质量软件中的作用是必要的——在了解如何正确执行方面投入时间，当构建大规模软件时将会有回报。

## 13.5 用良好的文档解释你的软件

超过五百页之后，说我是写作的大粉丝似乎有些多余。尽管如此，强调精心编写的文档在代码库中产生的积极影响是很重要的。

它的第一个好处是众所周知的：它帮助他人更快地理解代码库。文档对于他人理解代码本身特别有帮助，但更重要的是，*为什么*要以特定的方式编写。就我个人而言，为了保持文档简洁，我避免描述不同代码部分的工作方式，而是专注于解释它们的意图。

文档的最大问题是保持其更新。当你更新代码时，如果你的文档与代码不同步，其他人理解代码应该做什么会变得更加困惑，因为他们现在有两个相互冲突的信息来源。

为了避免这种情况，我个人喜欢将文档与代码尽可能保持接近。为了实现这一目标，我更喜欢使用 JSDoc 通过注释块来记录我的代码，而不是单独使用 Markdown 文件编写文档。

在代码文件中记录你的软件文档，几乎可以确保其他人不会忘记在编写代码时需要更新文档。如果某人正在更改的函数上方有 JSDoc 块，其他人就不需要花费时间搜索 Markdown 文件或更新单独的维基百科。

此外，如果你使用 JSDoc，你可以轻松地使用你的软件文档生成静态网站，并将它们发布到互联网上。其他人不一定需要查看你的代码来阅读其文档。

此外，许多文本编辑器和 IDE 可以解析 JSDoc，并在你编写代码时显示函数文档的提示信息。

注意：如果你想开始使用 JSDoc，我强烈建议你阅读该工具的官方文档，网址为[`jsdoc.app`](https://jsdoc.app)。

文档的第二个，在我看来，最具影响力的好处尚未得到广泛传播：编写文档迫使作者反思他们的选择并精确地组织他们的思想。这种工作反过来又往往导致更友好的设计，并帮助作者自己更好地理解代码库。正如普利策奖和全国图书奖获得者大卫·麦库卢赫曾经说过：“写作就是思考。写得越好，思考就越清晰。这就是为什么它如此困难。”

个人而言，我经常喜欢在编写任何代码之前编写文档。通过在编写代码之前解释代码的意图，我通常更少担心实现细节，并专注于模块消费者将需要什么。

最后，我对工程师的最后一条建议也是要记录他们的流程和贡献政策。拥有一份最新且写得好的工作协议有助于他人了解对他们有什么期望以及何时期望。

例如，记录你期望每个拉取请求都包含自动化测试，有助于将其正式化为一项良好实践，并在团队内设定期望。

## 摘要

+   当你编写测试时，你正在进行实验。你使用样本输入执行你的程序，并观察你的程序如何表现。然后，你选择外推这些结论，并相信程序将在未来的所有输入中以类似的方式表现。另一方面，类型允许你证明你的程序只能以特定方式工作。

+   通过使用类型系统，你可以在不执行程序本身的情况下证明程序的性质。这就是为什么类型检查被认为是“静态分析”过程的原因。

+   严格使用类型系统可以帮助你使无效状态无法表示，因此，使得你无法犯导致你的软件进入这些无效状态的错误。

+   此外，类型系统减少了某些函数可以接受的输入的可能宇宙，这使得软件更容易验证，因为你需要编写的自动化测试案例更少。

+   代码审查的存在是为了捕捉机器无法捕捉到的错误。尽管你可以使用自动化测试来验证你的代码，但你必须确保你的自动化测试是正确的，并且它们实现了预期的业务目标。为了验证软件开发这两个方面，你需要一双额外的眼睛来指出错误。

+   当提交拉取请求时，请写详细的描述。这些描述有助于你的审阅者工作，因为它们帮助他人了解你试图实现什么以及你为什么做出某些决定。

+   如果你是一个审查者，将拉取请求视为对话。通过以与作者沟通的意图来审查拉取请求，你将能够确保你已经提出了相关的问题，并且因为你试图创建一个有意义的沟通桥梁，你不可避免地会更加关注。此外，写赞美的话可以在团队中建立健康的人际关系。

+   在你的审查中明确指出哪些更改将阻止拉取请求获得你的批准。这种态度有助于团队避免关于双方都不认为相关的琐碎建议的讨论。

+   不要线性地审查代码。与其浏览多个文件，不如尝试跟随作者的思路。实施更改不是一个线性过程，因此，线性审查不允许审查者正确地跳过代码的依赖图。

+   Linting 是一种类似于类型检查的静态分析过程。Linters 分析你编写的代码，并验证它是否与可配置的规则集匹配，从而指示可能导致错误或不一致的问题。

+   格式化器专注于风格问题。它们确保你遵循一致的代码风格，并使代码更容易阅读。

+   Linters 和 formatters 减少了拉取请求中的挑剔性评论，因为代码标准是由机器而不是人类自动执行和验证的。

+   监控使你能够了解你的软件在客户手中的行为方式。因此，它有助于你检测你关于程序如何工作的错误假设。

+   通过监控你的软件，你可以了解其瓶颈在哪里，并衡量改进，从而避免过早优化和软件更新的试错方法的额外开销。

+   在你的监控基础设施之上设置警报有助于确保当应用程序的业务价值受到影响时，你的团队能够迅速采取行动。

+   在编写文档时，专注于解释代码的*意图*而不是其内部工作原理，这样你可以保持文档的简洁。

+   你可以使用 JSDoc 等工具将文档捆绑到你的代码库中。这些工具使代码成为唯一的真理来源，并减少了更新文档所需的时间和精力。

    在编写代码之前编写文档可以帮助你阐明你试图实现的目标，因为这样做时，你会专注于模块的接口和意图，而不是过分担心其实现细节。
