# 9 可读性

本章涵盖

+   单元测试的命名规范

+   编写可读的测试

没有可读性，你编写的测试对后来阅读它们的人来说几乎毫无意义。可读性是编写测试的人和几个月或几年后必须阅读它的可怜人之间的联系纽带。测试是你向项目的下一代程序员讲述的故事。它们允许开发者确切地看到应用程序由什么组成以及它从哪里开始。

这章主要确保在你之后的开发者能够维护你编写的生产代码和测试。他们需要理解他们在做什么以及他们应该在何处做。

可读性有几个方面：

+   命名单元测试

+   命名变量

+   将断言与操作分离

+   设置和拆除

让我们逐一分析。

## 9.1 命名单元测试

命名标准很重要，因为它们为你提供了舒适的规则和模板，概述了你应该解释关于测试的内容。无论我如何排序，或者我使用什么特定的框架或语言，我都试图确保这三个重要的信息点存在于测试的名称中或在测试存在的文件结构中：

+   单位工作入口点（或正在测试的功能的名称）

+   测试入口点的测试场景

+   单位工作出口点的预期行为

入口点（或工作单元）的名称至关重要，这样你可以轻松理解正在测试的逻辑的起始范围。将此作为测试名称的第一部分也允许在测试文件中进行轻松导航和即写即完成的操作（如果您的 IDE 支持的话）。

测试的场景给出了名称的“with”部分：“当我调用入口点 X *with*一个 null 值时，它应该执行 Y。”

单位工作出口点的预期行为是测试在平实的英语中指定单位工作应该做什么或返回什么，或者根据当前场景它应该如何表现：“当我调用入口点 X *with*一个 null 值时，它应该从这个单位工作的出口点可见地执行 Y。”

这三个元素必须位于阅读测试的人的视线附近。有时它们都可以封装在测试函数的名称中，有时你可以通过嵌套的`describe`结构来包含它们。有时你可以简单地使用字符串描述作为参数或注释来表示测试。

以下列出了一些示例，所有示例都包含相同的信息，但布局不同。

列表 9.1 相同的信息，不同的变体

```
test('verifyPassword, with a failing rule, returns error based on rule.reason', () => { ... }

describe('verifyPassword', () => {
  describe('with a failing rule', () => {
    it('returns error based on the rule.reason', () => { ... }

verifyPassword_withFailingRule_returnsErrorBasedonRuleReason()
```

你当然可以想出其他方法来组织这个结构。（谁说一定要用下划线？那只是我用来提醒自己和别人有三个方面信息的个人偏好。）需要记住的关键点是，如果你移除这些信息中的一个，你就是在迫使阅读测试的人阅读测试内部的代码来找出答案，浪费宝贵的时间。

下面的列表展示了缺少信息的测试示例。

列表 9.2 缺少信息的测试名称

```
test(failing rule, returns error based on rule.reason', () => { ... }      ❶

test('verifyPassword, returns error based on rule.reason', () => { ... }   ❷

test('verifyPassword, with a failing rule', () => { ... }                  ❸
```

❶ 要测试的是什么？

❷ 这应该在什么时候发生？

❸ 那接下来会发生什么？

你在可读性方面的主要目标是让下一个开发者从阅读测试代码的负担中解脱出来，以便理解测试在测试什么。

将所有这些信息包含在测试名称中的另一个很好的理由是，名称通常是自动化构建管道失败时唯一出现的东西。你会在构建失败的日志中看到失败的测试名称，但你看不到任何注释或测试代码。如果名称足够好，你可能不需要阅读测试代码或调试它们；你只需阅读失败的构建日志，就可能理解失败的原因。这可以节省宝贵的调试和阅读时间。

一个好的测试名称也有助于可执行文档的概念——如果你可以让一个刚加入团队的开发者阅读测试，以便他们可以理解特定组件或应用程序的工作方式，那么这是一个可读性的好迹象。如果仅从测试中无法理解应用程序或组件的行为，那么这可能是可读性的一个红旗。

## 9.2 魔法值和变量命名

你听说过“魔法值”这个术语吗？听起来很酷，但它恰恰相反。它应该真正被称为“巫术值”，以传达使用它们的负面影响。它们是什么？它们是硬编码的、未记录的或理解不佳的常量或变量。魔法一词的引用表明这些值是有效的，但你不知道为什么。

考虑以下测试。

列表 9.3 包含魔法值的测试

```
describe('password verifier', () => {
  test('on weekends, throws exceptions', () => {
))   ❶
      .toThrowError("It's the weekend!");
  });
});
```

❶ 魔法值

这个测试包含三个魔法值。一个没有编写测试且不了解被测试 API 的人能轻易理解 `0` 值的含义吗？`[]` 数组呢？那个函数的第一个参数看起来有点像密码，但甚至这一点也有一种神奇的感觉。让我们来讨论一下：

+   `0` 可能意味着很多事。作为读者，我可能需要在代码中四处搜索，或者跳到被调用函数的签名中，才能理解这指定的是星期几。

+   `[]` 强迫我查看被调用函数的签名，以理解该函数期望一个密码验证规则数组，这意味着测试验证的是没有规则的用例。

+   `jhGGu78!`看起来是一个明显的密码值，但作为一个读者，我会有的一个大问题是，为什么是这个特定的值？这个特定密码值有什么重要之处？显然，使用这个值而不是其他任何值对这个测试来说很重要，因为它看起来如此具体。实际上并不是这样，但读者不会知道这一点。他们可能会在其他测试中使用这个密码值只是为了安全起见。魔法值往往会自行在测试中传播。

以下列表显示了具有固定魔法值的相同测试。

列表 9.4 修复魔法值

```
describe("verifier2 - dummy object", () => {
  test("on weekends, throws exceptions", () => {
    const SUNDAY = 0, NO_RULES = [];
    expect(() => verifyPassword2("anything", NO_RULES, SUNDAY))
      .toThrowError("It's the weekend!");
  });
});
```

通过将具有意义名称的变量中放入魔法值，我们可以消除人们在阅读我们的测试时可能会有的疑问。对于密码值，我决定简单地改变直接值来向读者解释这个测试中*不*重要的事情。

变量名称和值同样重要的是向读者解释他们*不应该*关心的事情，就像它们是解释*什么*重要的一样。

## 9.3 将断言与操作分离

为了可读性和所有神圣的东西，避免在同一语句中编写断言和方法调用。以下列表显示了我是指什么。

列表 9.5 将断言与操作分离

```
expect(verifier.verify("any value")[0]).toContain("fake reason");   ❶

const result = verifier.verify("any value");                        ❷
expect(result[0]).toContain("fake reason");                         ❷
```

❶ 不好的例子

❷ 优秀的例子

看看这两个例子之间的区别？第一个例子由于行长度和操作和断言部分的嵌套，在真实测试的上下文中阅读和理解起来要困难得多。

如果你想要在调用后专注于结果值，那么调试第二个例子比第一个例子要容易得多。不要忽视这个小技巧。当你的测试没有让他们因为不理解而感到愚蠢时，他们会在你之后低声说一声小小的感谢。

## 9.4 设置和销毁

单元测试中的设置和销毁方法可能会被滥用到测试或设置和销毁方法本身变得难以阅读的程度。这种情况在设置方法中通常比在销毁方法中更糟糕。

以下列表显示了一种非常常见的滥用方式：使用设置（或`beforeEach`函数）来设置模拟或存根。

列表 9.6 使用设置（`beforeEach`）函数进行模拟设置

```
describe("password verifier", () => {
  let mockLog;
  beforeEach(() => {
    mockLog = Substitute.for<IComplicatedLogger>();         ❶
  });

  test("verify, with logger & passing, calls logger with PASS",() => {
    const verifier = new PasswordVerifier2([], mockLog);    ❷
    verifier.verify("anything");

    mockLog.received().info(                                ❷
      Arg.is((x) => x.includes("PASSED")),
      "verify"
    );
  });
}); 
```

❶ 设置模拟

❷ 使用模拟

如果你在一个设置方法中设置模拟和存根，这意味着它们在实际测试中不会被设置。这反过来意味着，阅读你的测试的人可能甚至都没有意识到正在使用模拟对象，或者测试期望它们做什么。

列表 9.6 中的测试使用了`mockLog`变量，该变量在`beforeEach`函数（一个设置方法）中初始化。想象一下，如果你在文件中有数十个或更多的这些测试，设置函数位于文件的开头，而你却卡在阅读文件底部的测试。你遇到了`mockLog`变量，你必须开始提出问题，例如，“这个是如何初始化的？它在测试中会如何表现？”等等。

如果在同一个文件中的各种测试中使用了多个模拟和存根，可能会出现另一个问题，那就是设置函数变成了所有测试使用的各种状态的垃圾桶。这会变得一团糟，像是一锅混合了众多参数的大杂烩，有些参数被一个测试使用，而其他参数则被用在其他地方。管理和理解这样的设置变得困难。

直接在测试中初始化模拟对象及其所有期望，这样更易于阅读。以下列表是一个在每个测试中初始化模拟的示例。

列表 9.7 避免设置函数

```
describe("password verifier", () => {
  test("verify, with logger & passing,calls logger with PASS",() => {
    const mockLog = Substitute.for<IComplicatedLogger>();             ❶

    const verifier = new PasswordVerifier2([], mockLog);
    verifier.verify("anything");

    mockLog.received().info(
      Arg.is((x) => x.includes("PASSED")),
      "verify"
    );
  });
```

❶ 在测试中初始化模拟

当我看这个测试时，一切都很清晰。我可以看到模拟何时被创建，它的行为，以及我需要知道的其他任何信息。

如果你担心可维护性，可以将模拟的创建重构为一个辅助函数，每个测试都会调用它。这样，你避免了通用的设置函数，而是从多个测试中调用相同的辅助函数。如下所示，你保持了可读性并获得了更多的可维护性。

列表 9.8 使用辅助函数

```
describe("password verifier", () => {
  test("verify, with logger & passing,calls logger with PASS",() => {
    const mockLog = makeMockLogger();                                 ❶

    const verifier = new PasswordVerifier2([], mockLog);
    verifier.verify("anything");

    mockLog.received().info(
      Arg.is((x) => x.includes("PASSED")),
      "verify"
    );
  });
```

❶ 使用辅助函数初始化模拟

并且是的，如果你遵循这个逻辑，你会发现我对你在测试中没有任何设置函数感到非常满意。我经常编写没有设置函数的完整测试套件，而是从每个测试中调用辅助方法，为了维护性。这些测试仍然可读且易于维护。

## 摘要

+   当命名一个测试时，包括正在测试的工作单元的名称、当前的测试场景以及工作单元的预期行为。

+   不要在测试中留下魔法值。要么用有意义的变量将它们包裹起来，要么如果是一个字符串，将描述放入值本身。

+   将断言与操作分开。合并两者缩短了代码，但会使代码理解难度显著增加。

+   尽量不要使用任何测试设置（例如`beforeEach`方法）。引入辅助方法来简化测试的安排部分，并在每个测试中使用这些辅助方法。
